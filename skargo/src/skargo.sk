module Skargo;

const kManifestFile: String = "Skargo.toml";
const kVersionFile: String = "version.sk";
const kDevProfile: String = "dev";
const kReleaseProfile: String = "release";
const kDebugProfile: String = "debug";
const kDefaultTarget: String = "host";
const kTargetDir: String = "target";

class SystemCallException(code: Int, error: ?String = None()) extends Exception

// private class Env{
//   rootDir: String,
//   manifest: Manifest,
//   console: Console,
//   config: UserConfig,
// } {
//   static fun create(verbosity: ConsoleVerbosity): Env {
//     rootDir = findRootDir();
//     config = findUserConfig();
//     Env{
//       rootDir,
//       manifest => Manifest::read(Path.join(rootDir, kManifestFile)),
//       console => Console(verbosity),
//       config,
//     }
//   }

//   fun getDependencies(): Map<String, Manifest> {
//     // TODO When we start having remote repositories, this will also download the dependencies.
//     getDependencies(this.manifest, this.config.repositories) match {
//     | Success(v) -> v
//     | Failure(e) -> throw e
//     };
//   }

//   static fun fromFile(path: String, verbosity: ConsoleVerbosity): Env {
//     rootDir = Path.dirname(path);
//     config = findUserConfig(Some(rootDir));
//     Env{
//       rootDir,
//       manifest => Manifest::read(path),
//       console => Console(verbosity),
//       config,
//     }
//   }
// }

// TODO: Support `--manifest-path`.
private fun findRootDir(): String {
  path = getcwd();

  loop {
    if (FileSystem.exists(Path.join(path, kManifestFile))) {
      return path
    };
    if (Path.isRoot(path)) {
      invariant_violation(
        `Could not find \`${kManifestFile}\` in \`${getcwd()} or any parent directory.\``,
      )
    };

    !path = Path.parentname(path)
  }
}

private fun profileOptions(profile: String): Array<String> {
  if (profile == kDevProfile || profile == kDebugProfile) {
    Array["-O0"]
  } else if (profile == kReleaseProfile) {
    Array["-O3"]
  } else {
    invariant_violation("Unrecognized profile " + profile)
  }
}

private fun run(args: Array<String>, console: Console): void {
  console.status_verbose("Running", args.join(" "));
  (stdout_cb, stderr_cb) = if (console.verbosity >= VerbosityProlix()) {
    (print_raw, print_error_raw)
  } else {
    ((_) -> void, (_) -> void)
  };

  p = System.subprocess(args, stdout_cb, stderr_cb);
  if (!p.success()) {
    console.error(
      "command exited with non-zero status\n\n" +
        "Caused by:\n" +
        "  process did not exit successfully: \`" +
        args[0] +
        `\` (exit status: ${p.exitcode()})\n` +
        "  --- stdout\n" +
        p.stdout.split("\n").map(l -> "  " + l).join("\n") +
        "\n" +
        "  --- stderr\n" +
        p.stderr.split("\n").map(l -> "  " + l).join("\n") +
        "\n",
    );
    throw SystemCallException(p.exitcode());
  }
}

const errorMappingAbort: Int = 6;
const errorMappingFailed: Int = 41;
const errorMappingMemory: Int = 42;
const errorMappingVersion: Int = 43;
const errorChangingCont: Int = 22;

fun isMappingError(code: Int): Bool {
  code == errorMappingAbort ||
    code == errorMappingFailed ||
    code == errorMappingMemory ||
    code == errorMappingVersion ||
    code == errorChangingCont
}

private fun invokeSkc(
  bc: BuildContext,
  target: Target,
  args: Array<String>,
  retry: Bool = true,
): void {
  targetFlag = bc.target_triple_for(target);
  if (!FileSystem.exists(bc.state_db)) {
    // TODO: Use stdlib abstraction instead of relying on the shell.
    _ = system("mkdir -p " + bc.target_dir);
    // TODO: Initialize with empty file list?
    run(
      Array[bc.skc, "--init", bc.state_db, "--check"].concat(
        Array[targetFlag].filterNone(),
      ).concat(target.srcs),
      bc.gctx.console,
    )
  };
  try {
    run(
      Array[bc.skc, "--data", bc.state_db].concat(
        Array[targetFlag].filterNone(),
      )
        .concat(args)
        .concat(target.srcs),
      bc.gctx.console,
    )
  } catch {
  | SystemCallException(
    code,
    _,
  ) if (bc.env.config.autoRemoveState && retry && isMappingError(code)) ->
    // TODO check the 6 origin
    run(Array["rm", bc.state_db], bc.gctx.console);
    invokeSkc(bc, target, args, false)
  | exn -> throw exn
  }
}

private fun compile(bc: BuildContext, target: Target, out_dir: String): void {
  main = target.kind match {
  | BinTarget(main) -> main
  | _ -> invariant_violation("Expected binary target")
  };
  output = bc.target_kind match {
  | CompileKindTarget(
    t,
  ) if (!target.for_host && TargetTriple::fromString(t).isWasm32()) ->
    target.name + ".wasm"
  | _ -> target.name
  };
  invokeSkc(
    bc,
    target,
    Array[
      "--export-function-as",
      `${main}=skip_main`,
      "-o",
      Path.join(out_dir, output),
    ].concat(profileOptions(bc.target_profile)),
  )
}

private fun genVersionFile(bc: BuildContext): void {
  // TODO: Ensure cwd.
  p = System.subprocess(Array["git", "rev-parse", "--short", "HEAD"]);
  hash = p.exitstatus match {
  | Posix.WExited(127)
  | Posix.WExited(128) ->
    // Fallback if current checkout is not a git repo, or git is not installed.
    "unknown"
  | Posix.WExited(0) -> p.stdout.trim()
  | _ ->
    print_raw(p.stdout);
    print_error_raw(p.stderr);
    invariant_violation("error")
  };
  kTarget = bc.target_kind.toString();
  target_dir = bc.target_dir_for_arch(kTarget);
  _ = system("mkdir -p " + target_dir);
  kWasm32 = bc.isWasm32();
  // Workaround for conditional compilation, but we should not rely on it long term
  contents = `module SkargoVersion;
const kVersion: String = "${
    bc.package.manifest.package_id.version
  }";
const kCommit: String = "${hash}";
const kProfile: String = "${
    bc.target_profile
  }";
const kTarget: String = "${
    bc.target_kind
  }";
const kWasm32: Bool = ${kWasm32};
module end;
`;

  FileSystem.writeTextFile(Path.join(target_dir, kVersionFile), contents)
}

private fun pascalCase(name: String): String {
  toupper = true;
  String::fromChars(
    name
      .chars()
      .map(c -> {
        if (c == '_') {
          !toupper = true;
        } else {
          !c = if (toupper) c.capitalize() else c;
          !toupper = false;
        };
        c
      })
      .toArray(),
  ).replace("_", "");
}

private fun generateManifestTemplate(
  name: String,
  optTestHarness: ?String = None(),
  version: String = "0.1.0",
): String {
  Array["[package]", `name = "${name}"`, `version = "${version}"`].concat(
    optTestHarness.map(th -> Array[`test-harness = "${th}"`]).default(Array[]),
  )
    .concat(
      Array[
        "",
        "[dependencies]",
        "prelude = *",
        "#depname = { \"path\" = \"deppath\" }",
        "#depname = { \"version\" = \"version\"  }",
        "#depname = { \"path\" = \"deppath\", \"version\" = \"version\"  }",
        "",
        "#[[bin]]",
        `#name = "${name.replace("_", "")}"`,
        `#main = "${pascalCase(name)}.main"`,
        "",
      ],
    )
    .join("\n");
}

fun checkBuildFiles(
  bc: BuildContext,
  test: Bool,
  building: List<Manifest>,
): void {
  // TODO manage when same dependency added multiple time with different name
  links = SortedSet[];
  libraries = mutable Vector[];
  preambles = mutable Vector[];
  bc.deps.each((_k, v) -> {
    if (!building.any(e -> v.package_id.name == e.package_id.name)) {
      !links = checkBuildFile(
        bc,
        v,
        links,
        libraries,
        preambles,
        test,
        building,
      )
    }
  });
  if (!libraries.isEmpty()) {
    Environ.set_var(
      "SKC_LINK",
      libraries.toArray().concat(links.toArray()).join(Path.listSeparator),
    );
  };
  if (!preambles.isEmpty()) {
    Environ.set_var("SKC_PREAMBLE", preambles.join(Path.listSeparator));
  }
}

fun checkBuildFile(
  bc: BuildContext,
  manifest: Manifest,
  links: SortedSet<String>,
  libraries: mutable Vector<String>,
  preambles: mutable Vector<String>,
  test: Bool,
  building: List<Manifest>,
): SortedSet<String> {
  // TODO manage version
  for (target in manifest.targets) {
    if (target.kind is CustomBuildTarget _) {
      if (target.srcs.size() != 1) {
        invariant_violation("Expected only one `build.sk` source for target")
      };
      skbuildPath = target.srcs[0];
      target_dir = Path.join(
        bc.target_dir_for(target),
        "build",
        manifest.package_id.name + "-build",
      );
      _ = system("mkdir -p " + target_dir);
      // bin = TomlBinary(
      //   manifest.package_id.name + "Build",
      //   `${pascalCase(manifest.package_id.name)}Build.main`,
      // );
      // bManifest = Manifest{
      //   package_id => manifest.package_id with {
      //     name => manifest.package_id.name + "_build",
      //   },
      //   path => targetDir,
      //   dependencies => manifest.dependencies
      //     .filter(d -> d.kind is BuildDep _)
      //     .collect(Array),
      //   targets => Array[Target()],
      // };
      // env = Env{
      //   rootDir => targetDir,
      //   manifest => bManifest,
      //   console => bc.gctx.console,
      //   config => bc.env.config,
      // };
      deps = getDependencies(Array[manifest], /* build = */ true);
      // sbc = BuildContext{
      //   env,
      //   skc => bc.skc,
      //   targetDir => bc.targetDir,
      //   target => None(),
      //   profile => bc.profile,
      //   state_db => Path.join(targetDir, "state.db"),
      //   files => getFiles(bc, env.manifest, deps).concat(
      //     Array[Path.join(bc.targetDir, kVersionFile)],
      //   ),
      //   deps,
      // };
      deps.each((_k, v) ->
        _ = Environ.set_var(`PCK_${v.package_id.name}`, v.path)
      );
      execBuildContext(sbc, bManifest.bin, List.Cons(dependency, building));
      binPath = Path.join(bc.targetDir, bin.name);
      Environ.set_var("OUT_DIR", targetDir);
      Environ.set_var("PCK_DIR", dependency.path);
      Environ.set_var("NAME", dependency.name);
      Environ.set_var("PROFILE", bc.profile);
      Environ.set_var(
        "VERBOSE",
        (bc.gctx.console.verbosity >= VerbosityVerbose()).toString(),
      );
      Environ.set_var("TEST", test.toString());
      bc.target match {
      | Some(t) -> Environ.set_var("TARGET", t.toString())
      | _ -> Environ.remove_var("TARGET")
      };

      _ = system("mkdir -p " + targetDir);
      buffer = "";
      onLine = line -> {
        if (line.startsWith("skargo:")) {
          artifact = line.splitFirst(":").i1;
          if (artifact.startsWith("library=")) {
            libraries.push(artifact.substring(artifact.getIter().drop(8)));
          } else if (artifact.startsWith("preamble=")) {
            preambles.push(artifact.substring(artifact.getIter().drop(9)));
          } else if (artifact.startsWith("link=")) {
            !links = links.set(artifact.substring(artifact.getIter().drop(5)));
          }
        }
      };
      if (bc.gctx.console.verbosity >= VerbosityVerbose()) {
        print_error(`>> ${binPath}`)
      };
      p = System.subprocess(
        binPath,
        str -> {
          lines = (buffer + str).split("\n");
          for (idx in Range(0, lines.size() - 1)) {
            onLine(lines[idx])
          }
        },
        str ->
          if (bc.gctx.console.verbosity >= VerbosityVerbose()) {
            print_error_raw(str)
          }
        ,
      );
      if (!buffer.isEmpty()) {
        onLine(buffer)
      };
      if (!p.success()) {
        if (bc.gctx.console.verbosity < VerbosityVerbose()) {
          print_raw(p.stdout);
          print_error_raw(p.stderr);
        };
        throw SystemCallException(p.exitcode())
      };
    }
  };
  links
}

private fun getFiles(
  bc: BuildContext,
  target: Target,
  deps: Map<String, Manifest>,
): Array<String> {
  // TODO: This is dirty but temporary.
  version_file = Path.join(bc.target_dir_for(target), kVersionFile);
  files = target.srcs.concat(Array[version_file]);
  for (dep in deps) {
    // NOTE: Since we currently do not have "library" targets, we're using an ugly
    // hack consisting of using the `tests` targets (always defined, and always
    // containing all sources) as a proxy.
    dep_srcs = dep.targets
      .find(t -> t.kind is BinTarget _ && t.name == "test")
      .fromSome().srcs;
    !files = files.concat(dep_srcs)
  };
  files
}

module end;
