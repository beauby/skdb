module Skargo;

class BuildRunner(
  bctx: BuildContext,
  // build_script_outputs,
  host_layout: Layout,
  target_layout: Layout,
  hashes: Map<Unit, Int>,
) {
  static fun create(bctx: BuildContext): BuildRunner {
    host_layout = Layout::create(
      bctx,
      None(),
      bctx.build_config.requested_profile,
    );
    target_layout = bctx.build_config.requested_arch match {
    | CompileKindHost() -> host_layout
    | CompileKindTarget(t) ->
      Layout::create(bctx, Some(t), bctx.build_config.requested_profile)
    };

    hashes = mutable Map[];
    for (unit in bctx.roots) {
      _ = hash_of(unit, bctx, hashes)
    };

    BuildRunner(bctx, host_layout, target_layout, hashes.chill())
  }

  fun compile(): void {
    this.prepare();
    started = mutable Set[];

    for (unit in this.bctx.build_plan()) {
      if (!started.contains(unit.pkg)) {
        started.add(unit.pkg);
        this.bctx.gctx.console.status("Compiling", unit.pkg.toString())
      };

      this.prepare_unit(unit);
      this.compile_unit(unit)
    }
  }

  private fun compile_unit(unit: Unit): void {
    unit.target.kind match {
    | BinTarget _
    | TestTarget _ ->
      this.compile_bin_unit(unit)
    | CustomBuildTarget _ ->
      this.compile_build_script(unit);
      this.run_build_script(unit)
    | LibTarget _ -> void
    }
  }

  private fun compile_bin_unit(unit: Unit): void {
    print_error("TODO " + unit.target.name)
  }

  private fun compile_build_script(unit: Unit): void {
    this.skc(unit);
  }

  private fun run_build_script(unit: Unit): void {
    build_script = Path.join(this.dest_dir_for(unit), unit.target.name);
    this.bctx.gctx.console.status_verbose("Running", build_script);
    print_error("TODO run build script")
  }

  private fun prepare(): void {
    this.host_layout.prepare();
    this.target_layout.prepare();
  }

  private fun layout_for_unit(unit: Unit): Layout {
    unit.kind match {
    | CompileKindHost() -> this.host_layout
    | _ -> this.target_layout
    }
  }

  private fun prepare_unit(unit: Unit): void {
    path = this.dest_dir_for(unit);
    _ = system(`mkdir -p ${path}`);

    unit.target.kind match {
    | CustomBuildTarget _ ->
      out_path = Path.join(path, "out");
      _ = system(`mkdir -p ${out_path}`)
    | _ -> void
    }
  }

  private fun skc(unit: Unit): void {
    args = mutable Vector[this.bctx.skc];

    unit.kind match {
    | CompileKindHost() -> void
    | CompileKindTarget(t) -> args.push(`--target=${t}`)
    };

    // TODO: state.db

    for (file in tmp_get_files(unit, this.bctx.unit_graph)) {
      args.push(file)
    };

    output_file = Path.join(
      this.dest_dir_for(unit),
      unit.target.name + this.suffix_for(unit),
    );
    args.extend(Array["-o", output_file]);

    this.bctx.gctx.console.status_verbose(
      "Running",
      "`" + args.join(" ") + "`",
    );
    // (stdout_cb, stderr_cb) = if (
    //   this.bctx.gctx.console.verbosity >= VerbosityProlix()
    // ) {
    //   (print_raw, print_error_raw)
    // } else {
    //   ((_) -> void, (_) -> void)
    // };
    // p = System.subprocess(args.collect(Array), stdout_cb, stderr_cb);
    // if (!p.success()) {
    //   this.bctx.gctx.console.error(
    //     "command exited with non-zero status\n\n" +
    //       "Caused by:\n" +
    //       "  process did not exit successfully: \`" +
    //       args[0] +
    //       `\` (exit status: ${p.exitcode()})\n` +
    //       "  --- stdout\n" +
    //       p.stdout.split("\n").map(l -> "  " + l).join("\n") +
    //       "\n" +
    //       "  --- stderr\n" +
    //       p.stderr.split("\n").map(l -> "  " + l).join("\n") +
    //       "\n",
    //   );
    //   throw SystemCallException(p.exitcode());
    // }
  }

  private fun dest_dir_for(unit: Unit): String {
    layout = this.layout_for_unit(unit);
    unit.target.kind match {
    | TestTarget _
    | BinTarget _ ->
      layout.root
    | LibTarget _ -> Path.join(layout.deps, this.dir_name_for(unit))
    | CustomBuildTarget _ -> Path.join(layout.build, this.dir_name_for(unit))
    }
  }

  private fun dir_name_for(unit: Unit): String {
    unit.pkg.name() + "-" + this.hashes[unit].toStringHex()
  }

  private fun suffix_for(unit: Unit): String {
    unit.target.kind match {
    | BinTarget _ ->
      unit.kind match {
      | CompileKindTarget(t) if (TargetTriple::fromString(t).isWasm32()) ->
        ".wasm"
      | _ -> ""
      }
    | LibTarget _ -> ".sklib"
    | _ -> ""
    };
  }
}

// This is a temporary hack before skc properly handles sklibs.
fun tmp_get_files(unit: Unit, unit_graph: UnitGraph): Array<String> {
  files = mutable Vector[];
  queue = mutable Vector[unit];
  pos = 0;
  while (pos < queue.size()) {
    cur_unit = queue[pos];
    files.extend(cur_unit.target.srcs);
    !pos = pos + 1;

    for (dep in unit_graph[cur_unit]) {
      if (queue.find(u -> u == dep) is Some _) continue;
      queue.push(dep);
    }
  };

  files.collect(Array)
}

private fun hash_of(
  unit: Unit,
  bctx: BuildContext,
  out: mutable Map<Unit, Int>,
): Int {
  if (!out.containsKey(unit)) {
    print_error("Computing for " + unit);
    dep_hashes = mutable Vector[];
    for (dep in bctx.unit_graph[unit]) {
      dep_hashes.push(hash_of(dep, bctx, out))
    };

    out.set(unit, compute_hash(unit, dep_hashes.collect(Array), bctx))
  };

  out[unit]
}

private fun compute_hash(
  unit: Unit,
  dep_hashes: Array<Int>,
  bctx: BuildContext,
): Int {
  (
    unit.pkg.manifest.package_id,
    dep_hashes,
    bctx.build_config,
    unit.target.name,
    unit.target.kind,
  ).hash()
}

module end;
