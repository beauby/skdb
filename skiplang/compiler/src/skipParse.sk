/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*****************************************************************************/
/* Utility functions to perform the parsing. */
/*****************************************************************************/
module alias Error = SkipError;

module FileCache;

class InputPackage(
  pkg_dir: ?String,
  srcs: Array<(String, Int)>,
) extends SKStore.File

const packageDirName: SKStore.DirName = SKStore.DirName::create(
  "/packageCache/",
);
const packageDir: SKStore.EHandle<SKStore.SID, InputPackage> = SKStore.EHandle(
  SKStore.SID::keyType,
  InputPackage,
  packageDirName,
);

class InputSource(
  pkg_opt: ?String,
  dir: String,
  path: String,
) extends SKStore.Key uses Show, Hashable {
  fun toString(): String {
    this.pkg_opt.map(p -> `${p}:`).default("") + this.path
  }
}

const fileDirName: SKStore.DirName = SKStore.DirName::create("/fileCache/");
const fileDir: SKStore.EHandle<
  InputSource,
  SKStore.StringFile,
> = SKStore.EHandle(
  InputSource::keyType,
  SKStore.StringFile::type,
  fileDirName,
);

// Contains the paths of all source files the analysis of which has
// been kept so far.
const allFilesDirName: SKStore.DirName = SKStore.DirName::create(
  "/allFilesCache/",
);
const allFilesDir: SKStore.EHandle<SKStore.IID, InputPackage> = SKStore.EHandle(
  SKStore.IID::keyType,
  InputPackage::type,
  allFilesDirName,
);

fun pkgDelta(
  old_srcs: Array<(String, Int)>,
  new_srcs: Array<(String, Int)>,
): (Array<String, String>, Array<String, String>, Array<String, String>) {
  added_files = mutable Vector[];
  modified_files = mutable Vector[];
  deleted_files = mutable Vector[];

  // FIXME: This is O(n^2).
  for ((src, mtime) in new_srcs) {
    old_srcs.find(s -> s.i0 == src) match {
    | Some((_, old_mtime)) ->
      if (mtime != old_mtime) {
        modified_files.push(src)
      }
    | None() -> added_files.push(src)
    }
  };

  // FIXME: This is O(n^2).
  for ((src, _) in old_srcs) {
    if (!new_srcs.any(s -> s.i0 == src)) {
      deleted_files.push(src)
    }
  };

  (
    added_files.collect(Array),
    modified_files.collect(Array),
    deleted_files.collect(Array),
  )
}

fun writeFiles(
  context: mutable SKStore.Context,
  file_names: Array<String>,
  dependencies: Map<String, (String, Sklib.Metadata)>,
  lib_name_opt: ?String,
): void {
  // Files in the current graph.
  current_files = mutable Map[
    lib_name_opt => InputPackage(
      lib_name_opt,
      getcwd(),
      file_names
        .map(fn ->
          (
            fn,
            FileSystem.getLastModificationTime(fn),
            FileSystem.readTextFile(fn),
          )
        )
        .collect(Array),
    ),
  ];
  for (dep_name => dep in dependencies) {
    (_, dep_meta) = dep;
    current_files.set(
      InputPackage(Some(dep_name), dep_meta.pkg_dir, dep_meta.sources),
    )
  };

  // Files kept in the previous run.
  old_files = mutable Map[];
  for (pkg in allFilesDir.unsafeGetArray(context, SKStore.IID(0))) {
    old_files.set(pkg.name, pkg.srcs.map(src -> (pkg.src_dir, src)))
  };

  stale_pkgs = mutable Vector<?String>[];
  if (lib_name_opt is Some _) {
    // Invalidate non-package source files.
    stale_pkgs.push(None())
  };
  // For each current package, invalidate files that were modified or deleted.
  for (pkg_opt => srcs in current_files) {
    (added_files, modified_files, deleted_files) = if (
      old_files.containsKey(pkg_opt)
    ) {
      pkgDelta(old_files[pkg_opt], srcs.map(src -> (src.i0, src.i1, src.i2)));
    } else {
      (srcs, Array[], Array[])
    };

    if (
      added_files.isEmpty() &&
      modified_files.isEmpty() &&
      deleted_files.isEmpty()
    ) {
      continue
    };
    stale_pkgs.push(pkg_opt);

    // Update added/modified files.
    for ((pkg_dir, src_path) in added_files.concat(modified_files)) {
      // FIXME: This is O(n).
      src_contents = srcs.find(src ~> src.i0 == src_path).fromSome().i2;
      fileDir.writeArray(
        context,
        InputSource(pkg_opt, pkg_dir, src_path),
        Array[SKStore.StringFile(src_contents)],
      )
    };
    // Invalidate deleted files.
    for ((pkg_dir, src_path) in deleted_files) {
      fileDir.writeArray(
        context,
        InputSource(pkg_opt, pkg_dir, src_path),
        Array[SKStore.StringFile("")],
      )
    }
  };

  new_old_files = current_files
    .map((_, pkg) -> {
      (pkg_dir, srcs) = pkg;
      (pkg_dir, srcs.map(src -> (src.i0, src.i1)))
    })
    .clone();
  // Keep analysis for all non-stale packages.
  for (pkg_opt => srcs in old_files) {
    // FIXME: This is O(n).
    if (stale_pkgs.contains(pkg_opt)) {
      continue
    };
    new_old_files.set(pkg_opt, srcs)
  };

  allFilesDir.writeArray(
    context,
    SKStore.IID(0),
    new_old_files
      .items()
      .map(pkg -> InputPackage(pkg.i0, pkg.i1.i0, pkg.i1.i1))
      .collect(Array),
  );
}

module end;

module SkipParse;

const astDirName: SKStore.DirName = SKStore.DirName::create("/astCache/");
const astDir: SKStore.EHandle<SKStore.SID, DefsFile> = SKStore.EHandle(
  SKStore.SID::keyType,
  DefsFile::type,
  astDirName,
);

class DefsFile(value: List<SkipAst.Definition>) extends SKStore.File

fun getAst(
  context: mutable SKStore.Context,
  fileName: String,
): List<SkipAst.Definition> {
  astDir.get(context, SKStore.SID(fileName)).value
}

fun parseFile(file: FileCache.InputSource, source: String): DefsFile {
  fileResult = SkipParser.parseSource(source, true);
  ast = parseToAst(file, fileResult);
  DefsFile(ast)
}

fun parseToAst(
  file: FileCache.InputSource,
  parseResults: Parser.ParseResults,
): List<SkipAst.Definition> {
  parseResults.throwOnError(file);
  List::createFromItems(
    ConvertTree.Converter{file}.convertTree(parseResults.tree),
  );
}

module end;
