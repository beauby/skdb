/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module Sequence;

// A type that represents a concrete sequence of items with a finite size (that
// may change over time) that can be accessed by contiguous integer indices in
// the range 0 (inclusive) to `size()` (exclusive).
mutable base class .IndexedSequence<+T> extends Sequence<T> {
  // # Creating Sequences

  // Return a chilled (shallowly frozen) copy of this sequence.
  readonly fun chill(): readonly IndexedSequence<T>;

  // # Accessing Items

  // Get the item at the given index, throws if the index is out of bounds.
  readonly fun get(index: Int): T;

  overridable readonly fun values(): mutable Iterator<T> {
    mutable IndexedSequenceIterator<T>(this, 0, this.size(), 1)
  }

  // Get the item at the given index as Some() or return None() if the index
  // is out of bounds.
  overridable readonly fun maybeGet(index: Int): ?T {
    if (index.uge(this.size())) {
      None()
    } else {
      Some(this.get(index))
    }
  }

  // Get the first item in the container, throws if the container is empty.
  overridable readonly fun first(): T {
    this.get(0)
  }

  // Get the first item in the container as Some() if non-empty, or None() if
  // empty.
  overridable readonly fun maybeFirst(): ?T {
    this.maybeGet(0)
  }

  // Get the last item in the container, throws if the container is empty.
  overridable readonly fun last(): T {
    this.get(this.size() - 1)
  }

  // Get the last item in the container as Some() if non-empty, or None() if
  // empty.
  overridable readonly fun maybeLast(): ?T {
    this.maybeGet(this.size() - 1)
  }

  // Returns Some() with the index of the first item that equals the predicate
  // value, otherwise returns None().
  overridable readonly fun indexOf<S: Equality>[T: S](predicate: S): ?Int {
    index = -1;
    this.find(x -> {
      !index = index + 1;
      x == predicate
    }).map(_ -> index)
  }

  // Returns true if the sequence contains a value that equals the second value,
  // otherwise returns false.
  overridable readonly fun contains<S: Equality>[T: S](second: S): Bool {
    this.find(x -> x == second).isSome()
  }

  // # Composition/Transformation

  // Returns a new sequence representing the items of this sequence followed by
  // the items of the second sequence.
  overridable readonly fun concat<U>[T: U](
    second: readonly Sequence<U>,
  ): IndexedSequence<U> {
    result = Vector<U>::mcreateFromItems(this);
    result.extend(second);
    unsafe_chill_trust_me(result)
  }

  // # Selecting Portions of a Sequence

  // Returns the items of this container from the start index (inclusive) up to
  // the end index (exclusive). The start/end values may be negative, in which
  // case they refer to the nth index before the end of the container.
  // For example, `x.slice(0, -2)` is equivalent to `x.slice(0, x.size() - 2)`.
  overridable readonly fun slice(
    start: Int,
    end: Int = Int::max,
  ): readonly IndexedSequence<T> {
    sz = this.size();
    if (start < 0) {
      !start = max(0, sz + start);
    };
    if (end < 0) {
      !end = max(0, sz + end);
    };
    !start = min(sz, start);
    !end = min(sz, end);
    if (end <= start) {
      Vector[]
    } else {
      capacity = end - start;
      Vector::fillBy(capacity, i -> this.get(i + start))
    }
  }

  // Returns the items of this container that do not appear in the second
  // sequence.
  overridable readonly fun difference<S: readonly Sequence<T>>[
    T: Hashable & Equality,
  ](
    second: S,
  ): IndexedSequence<T> {
    result = Vector::mcreate(0);
    set = UnorderedSet::mcreate(second.size());
    second.each(set.add);
    this.each(value -> {
      if (!set.contains(value)) {
        result.push(value)
      }
    });
    unsafe_chill_trust_me(result)
  }

  // Return the items of this container that appear in the second sequence.
  overridable readonly fun intersection<S: readonly Sequence<T>>[
    T: Hashable & Equality,
  ](
    second: S,
  ): IndexedSequence<T> {
    result = Vector::mcreate(0);
    set = UnorderedSet::mcreate(second.size());
    second.each(set.add);
    this.each(value -> {
      if (set.contains(value)) {
        result.push(value)
      }
    });
    unsafe_chill_trust_me(result)
  }

  // Return the unique items of this container.
  overridable readonly fun unique[T: Hashable & Equality](): IndexedSequence<
    T,
  > {
    // TODO: use a heuristic to avoid reallocation in avg case
    set = Map<T, void>::mcreate(0);
    this.each(value -> {
      set.set(value, void);
    });
    result = Vector::mcreate(set.size());
    set.each((value, _) -> {
      result.push(value);
    });
    unsafe_chill_trust_me(result)
  }

  // Returns up to N items randomly sampled from this container using a
  // pseudo-random generator initialized with the given seed. Returns all items
  // if N is greater than or equal to the size of the container. For a
  // collection of Hashable values, a deterministic random value can be
  // initialized with:
  //
  // ```
  // rng = Random::create(container.hash());
  // ```
  overridable readonly fun sample(
    rng: mutable Random,
    count: Int,
  ): readonly IndexedSequence<T> {
    sz = this.size();
    if (count == 0) {
      Vector[]
    } else if (sz <= count) {
      this.chill()
    } else {
      invariant(
        count >= 0,
        "Vector.sample(): Expected count to be nonnegative.",
      );

      // Algorithm R: copy the first K items to the output, then iterate over
      // the subsequent elements and randomly swap them into the output vector.
      sample = Vector::mcreateFromItems(this.slice(0, count));
      for (index in Range(count, sz)) {
        swap = rng.random(0, index + 1); // [0, index] - inclusive
        if (swap < count) {
          sample![swap] = this.get(index);
        }
      };
      unsafe_chill_trust_me(sample)
    }
  }

  // # Transforming To Different Sequence Types

  // Returns a tuple of (pass, fail) sequences: the pass sequence contains items
  // from this container for which the predicate returns true, the fail
  // sequence contains items for which the predicate returns false.
  overridable readonly fun partition(p: T -> Bool): (Sequence<T>, Sequence<T>) {
    pass = Vector::mcreate(0);
    fail = Vector::mcreate(0);
    this.each(value -> if (p(value)) pass.push(value) else fail.push(value));
    (unsafe_chill_trust_me(pass), unsafe_chill_trust_me(fail))
  }

  // Assigns each item to a key via the selection function, and then returns
  // a Map of key to items that mapped to that key.
  overridable readonly fun groupBy<K: Hashable & Equality>(
    s: T -> K,
  ): Map<K, Sequence<T>> {
    result = mutable Map[];
    this.each(value -> {
      key = s(value);
      items = result.getOrAdd(key, () -> Vector::mcreate(0));
      items.push(value);
    });
    unsafe_chill_trust_me(
      result.map((_, items) -> unsafe_chill_trust_me(items)),
    )
  }

  // # Async

  // When this sequence contains awaitables, asynchronously resolves this sequence
  // to a sequence of the their awaited values.
  //
  // # Visual Example
  //
  // Before:
  //   [ ^1, ^2, ^3, ^5]
  // After:
  //   ^[ 1, 2, 3, 5]
  // async frozen fun gen<U>[T: ^U](): ^IndexedSequence<U>;

  // Returns a new sequence representing the results of calling the selection
  // function on each element of this sequence and awaiting all the results.
  // Analogous to map().gen().
  overridable async frozen fun genMap<U: frozen>(
    s: T ~> ^U,
  ): ^IndexedSequence<U> {
    sz = this.size();
    nextInner = await ASIO.genFillBy(sz, index ~>
      async {
        awaitable_x = s(this[index]);
        await awaitable_x;
      }
    );
    Vector<U>::createFromItems(nextInner)
  }

  // Returns a new sequence representing all the elements of this sequence
  // for which the async predicate returns true.
  overridable async frozen fun genFilter(p: T ~> ^Bool): ^IndexedSequence<T> {
    // Asynchronously map each item to whether it passes the predicate or not
    sz = this.size();
    predicates = await ASIO.genFillBy(sz, index ~> p(this[index]));
    // Count the number of matching items to allocate a single exactly sized Array
    nextSz = predicates.reduce(
      (sum, predicate) -> if (predicate) sum + 1 else sum,
      0,
    );
    // Insert items into a return Array for which the predicate returned true
    next = mutable Vector<T>[];
    fromIndex = 0;
    toIndex = 0;
    // NOTE: The check for `fromIndex.ult(sz)` is skipped here because there
    // are guaranteed to be `nextSz` items in `inner` for which the predicate
    // passes and that cause `toIndex` to be incremented.
    while (toIndex.ult(nextSz)) {
      if (predicates[fromIndex]) {
        next![toIndex] = this[fromIndex];
        !toIndex = toIndex + 1;
      };
      !fromIndex = fromIndex + 1;
    };
    unsafe_chill_trust_me(next)
  }

  // Returns Some(x) for the first item in this sequence that matches
  // the async predicate, or None() if no items match.
  overridable async frozen fun genFind(p: T ~> ^Bool): ^?T {
    await this.genFindTailLoop(p, 0);
  }

  private async frozen fun genFindTailLoop<U>[T: U](
    p: U ~> ^Bool,
    index: Int,
  ): ^?U {
    if (index == this.size()) {
      None();
    } else {
      item = this[index];
      if (await p(item)) {
        Some<U>(item);
      } else {
        await this.genFindTailLoop(p, index + 1);
      };
    };
  }

  // Returns true if the async predicate returns true for all elements of this
  // sequence.
  overridable async frozen fun genAny(p: T ~> ^Bool): ^Bool {
    (await this.genFind(p)).isSome()
  }

  // Returns true if the async predicate returns true for at least one element
  // of this sequence.
  overridable async frozen fun genAll(p: T ~> ^Bool): ^Bool {
    (await this.genFind(x ~>
      async {
        !(await p(x))
      }
    )).isNone()
  }
}

mutable base class .MutableIndexedSequence<+T> extends IndexedSequence<T> {
  // # Adding/Changing/Removing Items

  // Set the value at the given index. Throws if the index is out of bounds.
  // NOTE: To add items to the end of a container use push().
  mutable fun set(index: Int, value: T): void;

  private mutable fun move(src: Int, dst: Int, count: Int): void {
    size = this.size();
    invariant(src.ule(size), "invalid start");
    invariant(dst.ule(size), "invalid start2");
    invariant(count >= 0, "invalid count");
    invariant((src + count) <= size, "invalid count");
    invariant((dst + count) <= size, "invalid count");

    if (src > dst) {
      for (i in Range(0, count)) this![dst + i] = this[src + i];
    } else if (src < dst) {
      for (i in Range(0, count)) {
        idx = count - 1 - i;
        this![dst + idx] = this[src + idx];
      };
    }
  }

  // # Reordering Items

  private mutable fun swap(i: Int, j: Int): void {
    tmp = this[i];
    this![i] = this[j];
    this![j] = tmp;
  }

  // Reverses the order of the items in the container.
  overridable mutable fun reverse(): void {
    size = this.size();
    for (i in Range(0, size / 2)) this.swap(i, size - 1 - i);
  }

  // Randomize the order of items in the container using a pseudo-random
  // generator initialized with the given seed. For a collection of Hashable
  // values, a deterministic random value can be initialized with:
  //
  // ```
  // rng = Random::create(container.hash());
  // ```
  overridable mutable fun shuffle(rng: mutable Random): void {
    // Deterministic shuffle using the Fisher–Yates algorithm.
    size = this.size();
    for (i in Range(0, size - 1)) {
      swap = rng.random(i, size);
      this.swap(i, swap);
    }
  }

  // Sorts the items in place using their default ordering.
  // To sort a collection of non-Orderable items, use sortBy().
  overridable mutable fun sort[T: readonly Orderable](
    compare: (T, T) ~> Order = (x, y) ~> x.compare(y),
  ): void {
    this.sortBy(id, compare);
  }

  // Sorts the items in place, using the given predicate to determine ordering.
  // To sort a collection of non-Orderable items, use Orderable.create():
  //
  //    a: IndexedSequence<NonOrderable> = ...;
  //    compareFn = (a: NonOrderable, b: NonOrderable): Order ~> { ... };
  //    b = a.sortBy(x ~> Orderable.create(x, compareFn));
  overridable mutable fun sortBy<K: readonly Orderable>(
    selector: T ~> K,
    compare: (K, K) ~> Order = (x, y) ~> x.compare(y),
  ): void {
    tmp = Array::mcreateFromItems(this);
    tmp.sortBy(selector, compare);
    for ((i, v) in tmp.items()) {
      this![i] = v
    }
  }
}

private mutable class IndexedSequenceIterator<T>(
  container: readonly IndexedSequence<T>,
  mutable start: Int,
  mutable size: Int,
  stride: Int,
) extends Iterator<T> {
  readonly fun sizeHint(): ?Int {
    Some(this.size)
  }

  mutable fun next(): ?T {
    if (this.size > 0) {
      cur = this.start;
      this.!start = cur + this.stride;
      this.!size = this.size - 1;
      Some(this.container[cur])
    } else {
      None()
    }
  }
}

private mutable class IndexedSubsequence<+T, U: readonly IndexedSequence<T>>(
  inner: U,
  range: Range,
) extends IndexedSequence<T> uses AsBytes[U: AsBytes] {
  readonly fun chill(): IndexedSequence<T> {
    IndexedSubsequence(this.inner.chill(), this.range)
  }

  readonly fun get(index: Int): T {
    this.inner.get(this.range.start + index)
  }

  readonly fun size(): Int {
    this.range.size()
  }

  readonly fun slice(
    start: Int,
    end: Int = Int::max,
  ): readonly IndexedSequence<T> {
    mutable IndexedSubsequence(this.inner, this.range.subrange(start, end))
  }

  readonly fun bytes[U: AsBytes](): readonly Bytes {
    invariant_violation("TODO")
  }
}

private mutable class MutableIndexedSubsequence<
  +T,
  U: mutable MutableIndexedSequence<T>,
>(
  inner: U,
  range: Range,
)
  extends MutableIndexedSequence<T>
  uses AsBytes[U: AsBytes], AsMutableBytes[U: AsMutableBytes] {
  readonly fun chill(): IndexedSequence<T> {
    IndexedSubsequence(this.inner.chill(), this.range)
  }

  readonly fun get(index: Int): T {
    this.inner.get(this.range.start + index)
  }

  mutable fun set(index: Int, value: T): void {
    this.inner.set(this.range.start + index, value)
  }

  readonly fun size(): Int {
    this.range.size()
  }

  readonly fun slice(
    start: Int,
    end: Int = Int::max,
  ): readonly IndexedSequence<T> {
    mutable IndexedSubsequence(this.inner, this.range.subrange(start, end))
  }

  mutable fun mslice(
    start: Int,
    end: Int = Int::max,
  ): mutable MutableIndexedSequence<T> {
    mutable MutableIndexedSubsequence(
      this.inner,
      this.range.subrange(start, end),
    )
  }

  readonly fun bytes[U: AsBytes](): readonly Bytes {
    invariant_violation("TODO")
  }

  mutable fun mbytes[U: AsMutableBytes](): mutable MutableBytes {
    invariant_violation("TODO")
  }
}

module end;
